<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3x3 Matrix Force Logger</title>
    <style>
        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
            text-align: center; color: #333;
            user-select: none; -webkit-touch-callout: none;
        }

        .container {
            display: flex; flex-direction: column; height: 100%; padding: 10px; box-sizing: border-box; position: relative;
        }
        
        /* ìƒë‹¨ íŒ¨ë„ */
        .top-panel {
            flex: 0 0 auto; background: white; padding: 15px; border-radius: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); margin-bottom: 10px; z-index: 2;
        }
        #current-force {
            font-size: 4em; font-weight: 900; color: #222; margin: 0; line-height: 1;
            font-variant-numeric: tabular-nums;
        }
        .status-text { font-size: 0.9em; color: #666; margin-top: 5px; display: flex; justify-content: space-between; padding: 0 10px;}

        /* í„°ì¹˜ ì˜ì—­ (ì¸¡ì • ëª¨ë“œ) */
        #touch-area {
            flex: 1; width: 100%; position: relative;
            background-color: #e9ecef; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 1.2em; font-weight: bold; color: #868e96;
            border: 4px dashed #adb5bd; margin-bottom: 10px;
            touch-action: none; overflow: hidden;
        }
        #touch-area.active { 
            background-color: #ffc9c9 !important; border-color: #ff6b6b !important; color: #c92a2a !important; 
        }

        /* í•˜ë‹¨ íŒ¨ë„ */
        .bottom-panel {
            flex: 0 0 auto; background: white; padding: 10px; border-radius: 15px; font-size: 0.9em; z-index: 2;
        }
        .control-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        
        button { border: none; border-radius: 8px; padding: 12px; font-weight: bold; font-size: 15px; cursor: pointer; width: 100%; transition: 0.2s; }
        .btn-blue { background-color: #339af0; color: white; }
        .btn-green { background-color: #20c997; color: white; }
        .btn-gray { background-color: #e9ecef; color: #333; }
        button:disabled { background-color: #dee2e6; color: #adb5bd; cursor: not-allowed; }

        /* === 3x3 ë³´ì • ìœ„ìë“œ ì˜¤ë²„ë ˆì´ === */
        #calib-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.98); z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 10px; box-sizing: border-box;
        }
        .wizard-header { margin-bottom: 20px; }
        
        /* 3x3 ê·¸ë¦¬ë“œ ì‹œê°í™” */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 300px; height: 300px;
            margin-bottom: 20px;
        }
        .grid-cell {
            background: #eee; border: 2px solid #ddd; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 0.8em; color: #aaa;
        }
        .grid-cell.target {
            background: #ffe3e3; border-color: red; color: red; font-weight: bold;
            box-shadow: 0 0 10px rgba(255,0,0,0.2);
            animation: pulse 1.5s infinite;
        }
        .grid-cell.done {
            background: #d3f9d8; border-color: #20c997; color: #0ca678;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #drag-status.warning { color: red; font-weight: bold; }
        input[type=number] { padding: 8px; width: 80px; text-align: center; border: 1px solid #ccc; border-radius: 5px; font-size: 1.2em; }
    </style>
</head>
<body>

<div class="container">
    <div class="top-panel">
        <div class="status-text">
            <span>Force (N)</span>
            <span id="drag-status">ëŒ€ê¸°ì¤‘</span>
        </div>
        <h1 id="current-force">0.000</h1>
    </div>

    <div id="touch-area">
        <div id="touch-msg">
            <div style="font-size: 2rem;">ğŸ‘‡</div>
            <div style="margin-top:10px;">ëˆ„ë¥´ë©´ ì¸¡ì •ë©ë‹ˆë‹¤</div>
        </div>
        <div style="position:absolute; width:100%; height:33%; top:33%; border-top:1px dashed #ccc; border-bottom:1px dashed #ccc; pointer-events:none;"></div>
        <div style="position:absolute; width:33%; height:100%; left:33%; border-left:1px dashed #ccc; border-right:1px dashed #ccc; pointer-events:none;"></div>
    </div>

    <div class="bottom-panel">
        <button class="btn-gray" onclick="startCalibrationMode()">âš™ï¸ 3x3 ì •ë°€ ë³´ì • (ë‹¤ì‹œí•˜ê¸°)</button>
        <div style="margin-top:10px; font-size: 0.8em; color: #555;" id="log-count">ë°ì´í„°: 0ê±´</div>
        <button id="download-btn" class="btn-blue" style="margin-top:5px;" disabled>ğŸ“¥ ì—‘ì…€(CSV) ì €ì¥</button>
    </div>

    <div id="calib-overlay">
        <div id="calib-start" style="text-align: center;">
            <h2>ğŸ“ 3x3 ì •ë°€ ë³´ì •</h2>
            <p>í™”ë©´ì„ 9ê°œ êµ¬ì—­ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ë³´ì •í•©ë‹ˆë‹¤.<br>ë¬¼ì²´ì˜ ë¬´ê²Œë¥¼ ì…ë ¥í•˜ì„¸ìš”.</p>
            <div style="margin: 20px;">
                <input type="number" id="wizard-weight" value="100"> g
            </div>
            <button class="btn-green" onclick="startWizard()">ì‹œì‘í•˜ê¸°</button>
            <br><br>
            <button class="btn-gray" onclick="closeCalibration()">ê±´ë„ˆë›°ê¸°</button>
        </div>

        <div id="calib-process" style="display:none; width:100%; text-align:center;">
            <h3 id="step-title">Step 1 / 9</h3>
            <p style="font-size:0.9em; color:#666;">ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ê¹œë¹¡ì´ëŠ” ì¹¸ì—<br>ë¬¼ì²´ë¥¼ ì˜¬ë¦¬ê³  ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.</p>
            
            <div class="grid-container" id="grid-visual">
                </div>

            <div style="font-weight:bold; margin-bottom:10px;">Raw Value: <span id="calib-raw">0.00</span></div>
            <button class="btn-green" onclick="captureCurrentStep()">ì¸¡ì • ë° ë‹¤ìŒ</button>
        </div>
    </div>
</div>

<script>
    // === ì „ì—­ ë³€ìˆ˜ ===
    const touchArea = document.getElementById('touch-area');
    const forceDisplay = document.getElementById('current-force');
    const dragStatusDisplay = document.getElementById('drag-status');
    const logCountDisplay = document.getElementById('log-count');
    const downloadBtn = document.getElementById('download-btn');
    const calibOverlay = document.getElementById('calib-overlay');
    const G_TO_N = 0.00980665; 

    // ë°ì´í„° ì €ì¥ì†Œ
    let logData = [];
    let loggingInterval = null;
    let isTouching = false;
    let startTime = 0;

    // ì›€ì§ì„ ê³„ì‚°ìš©
    let currentRawForce = 0;
    let currentForceN = 0;
    let currentX = 0, currentY = 0;
    let lastLogX = 0, lastLogY = 0;
    let isDragging = false;

    // === 3x3 ë³´ì • ë³€ìˆ˜ ===
    let targetWeightGram = 100;
    let isCalibrated = false;
    let defaultFactor = 385 * G_TO_N;

    // ë³´ì • í¬ì¸íŠ¸ (9ê°œ)
    // 0:TL, 1:TM, 2:TR, 3:ML, 4:MM, 5:MR, 6:BL, 7:BM, 8:BR
    // ì•µì»¤ ìœ„ì¹˜: Widthì˜ 20%, 50%, 80% / Heightì˜ 20%, 50%, 80%
    let calibPoints = Array(9).fill(0).map(() => ({ raw: 0, factor: 0 }));
    let currentStep = 0;

    const GRID_X = [0.2, 0.5, 0.8]; // 20%, 50%, 80% ì§€ì 
    const GRID_Y = [0.2, 0.5, 0.8];

    // === ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ===
    createGridVisuals();
    startCalibrationMode(); // ì‹œì‘ ì‹œ ìë™ ì‹¤í–‰

    touchArea.addEventListener('touchstart', handleTouchStart, { passive: false });
    touchArea.addEventListener('touchmove', handleTouchMove, { passive: false });
    touchArea.addEventListener('touchend', handleTouchEnd, { passive: false });

    // === í„°ì¹˜ í•¸ë“¤ëŸ¬ ===
    function handleTouchStart(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            resetSession();
            isTouching = true;
            touchArea.classList.add('active');
            document.getElementById('touch-msg').style.display = 'none';

            currentX = e.touches[0].clientX;
            currentY = e.touches[0].clientY;
            lastLogX = currentX;
            lastLogY = currentY;
            isDragging = false;
            
            startTime = Date.now();
            startLogging();
        }
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (e.touches.length > 0) {
            const touch = e.touches[0];
            currentRawForce = touch.force || touch.webkitForce || 0;
            currentX = touch.clientX;
            currentY = touch.clientY;

            // ë³´ì • ëª¨ë“œì¼ ë•Œ UI ì—…ë°ì´íŠ¸
            if (calibOverlay.style.display !== 'none') {
                document.getElementById('calib-raw').innerText = currentRawForce.toFixed(3);
                return;
            }

            // ì¸¡ì • ëª¨ë“œ: 3x3 ë³´ê°„ë²• ì ìš©
            currentForceN = calculateBilinearForce(currentRawForce, currentX, currentY);
            forceDisplay.innerText = currentForceN.toFixed(3);
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        stopLogging();
        isTouching = false;
        
        currentRawForce = 0;
        currentForceN = 0;
        isDragging = false;
        
        forceDisplay.innerText = "0.000";
        dragStatusDisplay.innerText = "ëŒ€ê¸°ì¤‘";
        dragStatusDisplay.classList.remove('warning');
        touchArea.classList.remove('active');
        document.getElementById('touch-msg').style.display = 'block';
        
        if (logData.length > 1) downloadBtn.disabled = false;
    }

    // === í•µì‹¬: ì´ì¤‘ ì„ í˜• ë³´ê°„ë²• (Bilinear Interpolation) ===
    function calculateBilinearForce(raw, xPx, yPx) {
        if (!isCalibrated) return raw * defaultFactor;

        const rect = touchArea.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;

        // ì¢Œí‘œ ì •ê·œí™” (0.0 ~ 1.0)
        let nx = (xPx - rect.left) / w;
        let ny = (yPx - rect.top) / h;
        nx = Math.max(0, Math.min(1, nx));
        ny = Math.max(0, Math.min(1, ny));

        // ì–´ëŠ êµ¬ê°„(Grid Cell)ì— ìˆëŠ”ì§€ ì°¾ê¸°
        // Grid Index: 0 (0.2~0.5 ì‚¬ì´), 1 (0.5~0.8 ì‚¬ì´) ... 
        // í¸ì˜ìƒ 2ê°œì˜ êµ¬ê°„ìœ¼ë¡œ ë‹¨ìˆœí™”: Left-Mid, Mid-Right
        
        // X êµ¬ê°„ ì¸ë±ìŠ¤ (0: Left-Mid êµ¬ê°„, 1: Mid-Right êµ¬ê°„)
        let xIdx = (nx < GRID_X[1]) ? 0 : 1;
        let yIdx = (ny < GRID_Y[1]) ? 0 : 1;

        // ë³´ê°„ ë¹„ìœ¨ ê³„ì‚° (0~1 ì‚¬ì´ ê°’)
        let u = (nx - GRID_X[xIdx]) / (GRID_X[xIdx+1] - GRID_X[xIdx]);
        let v = (ny - GRID_Y[yIdx]) / (GRID_Y[yIdx+1] - GRID_Y[yIdx]);

        // ë²”ìœ„ ë°– í´ë¨í•‘ (0.2 ë¯¸ë§Œì´ë‚˜ 0.8 ì´ˆê³¼ì¸ ê²½ìš° ê°€ê¹Œìš´ ê°’ìœ¼ë¡œ)
        u = Math.max(0, Math.min(1, u));
        v = Math.max(0, Math.min(1, v));

        // 4ê°œì˜ ì´ì›ƒ í¬ì¸íŠ¸ ì¸ë±ìŠ¤ ê³„ì‚°
        // calibPoints ë°°ì—´ êµ¬ì¡°: [TL, TM, TR, ML, MM, MR, BL, BM, BR]
        // Row 0: 0,1,2 | Row 1: 3,4,5 | Row 2: 6,7,8
        const p1_idx = (yIdx * 3) + xIdx;       // Top-Left
        const p2_idx = (yIdx * 3) + (xIdx + 1); // Top-Right
        const p3_idx = ((yIdx + 1) * 3) + xIdx;     // Bottom-Left
        const p4_idx = ((yIdx + 1) * 3) + (xIdx + 1); // Bottom-Right

        const f1 = calibPoints[p1_idx].factor;
        const f2 = calibPoints[p2_idx].factor;
        const f3 = calibPoints[p3_idx].factor;
        const f4 = calibPoints[p4_idx].factor;

        // Bilinear Formula
        // f(u,v) = (1-u)(1-v)f1 + u(1-v)f2 + (1-u)v*f3 + uv*f4
        const interpolatedFactor = 
            (1 - u) * (1 - v) * f1 +
            u * (1 - v) * f2 +
            (1 - u) * v * f3 +
            u * v * f4;

        return raw * interpolatedFactor;
    }

    // === ë³´ì • ìœ„ìë“œ ë¡œì§ ===
    function createGridVisuals() {
        const container = document.getElementById('grid-visual');
        container.innerHTML = '';
        const labels = ["TL", "TM", "TR", "ML", "MM", "MR", "BL", "BM", "BR"];
        for(let i=0; i<9; i++) {
            const div = document.createElement('div');
            div.className = 'grid-cell';
            div.id = `gc-${i}`;
            div.innerText = labels[i];
            container.appendChild(div);
        }
    }

    function startCalibrationMode() {
        calibOverlay.style.display = 'flex';
        document.getElementById('calib-start').style.display = 'block';
        document.getElementById('calib-process').style.display = 'none';
        currentStep = 0;
    }

    function startWizard() {
        const w = parseFloat(document.getElementById('wizard-weight').value);
        if(!w || w<=0) { alert("ë¬´ê²Œë¥¼ ì…ë ¥í•˜ì„¸ìš”"); return; }
        targetWeightGram = w;

        document.getElementById('calib-start').style.display = 'none';
        document.getElementById('calib-process').style.display = 'block';
        updateWizardUI();
    }

    function updateWizardUI() {
        document.getElementById('step-title').innerText = `Step ${currentStep+1} / 9`;
        
        // ê·¸ë¦¬ë“œ í•˜ì´ë¼ì´íŠ¸ ì´ˆê¸°í™”
        for(let i=0; i<9; i++) {
            const cell = document.getElementById(`gc-${i}`);
            cell.classList.remove('target');
            if(i < currentStep) cell.classList.add('done');
        }
        // í˜„ì¬ íƒ€ê²Ÿ
        if(currentStep < 9) {
            document.getElementById(`gc-${currentStep}`).classList.add('target');
        }
    }

    function captureCurrentStep() {
        if (currentRawForce <= 0.02) {
            alert("ë¬¼ì²´ê°€ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê¾¹ ëˆŒëŸ¬ì£¼ì„¸ìš”."); return;
        }

        calibPoints[currentStep].raw = currentRawForce;
        
        currentStep++;
        if(currentStep < 9) {
            updateWizardUI();
        } else {
            finishCalibration();
        }
    }

    function finishCalibration() {
        // ê³„ìˆ˜ ê³„ì‚°
        const targetN = targetWeightGram * G_TO_N;
        calibPoints.forEach(p => {
            p.factor = targetN / p.raw;
        });

        isCalibrated = true;
        closeCalibration();
        alert("3x3 ì •ë°€ ë³´ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!");
    }

    function closeCalibration() {
        calibOverlay.style.display = 'none';
    }

    // === ë¡œê¹… í•¨ìˆ˜ (ê¸°ì¡´ê³¼ ë™ì¼) ===
    function startLogging() {
        if (loggingInterval) clearInterval(loggingInterval);
        if(logData.length === 0) logData.push(["Time(s)", "Force(N)", "Raw", "X", "Y", "Moving"]);

        loggingInterval = setInterval(() => {
            if (!isTouching) return;
            const moveDist = Math.sqrt(Math.pow(currentX - lastLogX, 2) + Math.pow(currentY - lastLogY, 2));
            isDragging = moveDist > 2;
            lastLogX = currentX; lastLogY = currentY;

            if (isDragging) {
                dragStatusDisplay.innerText = "ì´ë™ ì¤‘ âš ï¸";
                dragStatusDisplay.classList.add('warning');
            } else {
                dragStatusDisplay.innerText = "ì•ˆì •";
                dragStatusDisplay.classList.remove('warning');
            }

            const now = Date.now();
            const timeSec = ((now - startTime) / 1000).toFixed(2);
            logData.push([timeSec, currentForceN.toFixed(4), currentRawForce.toFixed(4), currentX.toFixed(0), currentY.toFixed(0), isDragging ? "TRUE" : "FALSE"]);
            logCountDisplay.innerText = `ë°ì´í„°: ${logData.length - 1}ê±´`;
        }, 50); 
    }

    function stopLogging() {
        if (loggingInterval) clearInterval(loggingInterval);
        loggingInterval = null;
    }
    function resetSession() {
        logData = [];
        downloadBtn.disabled = true;
        logCountDisplay.innerText = "ë°ì´í„°: 0ê±´";
    }

    downloadBtn.addEventListener('click', () => {
        if (logData.length <= 1) return;
        let csvContent = "data:text/csv;charset=utf-8,\uFEFF"; 
        logData.forEach(row => csvContent += row.join(",") + "\r\n");
        const link = document.createElement("a");
        link.setAttribute("href", encodeURI(csvContent));
        const date = new Date();
        link.setAttribute("download", `Force_3x3_${date.getHours()}${date.getMinutes()}.csv`);
        document.body.appendChild(link);
        link.click(); document.body.removeChild(link);
    });
</script>

</body>
</html>
